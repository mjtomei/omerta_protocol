#!/bin/bash
# Git pre-commit hook - checks for sensitive data before each commit
# Setup: git config core.hooksPath .githooks

set -e

# Find the repo root (works in submodules too)
REPO_ROOT=$(git rev-parse --show-toplevel)

# Colors
RED='\033[0;31m'
NC='\033[0m'

# =============================================================================
# BLOCK: Any modifications to .env.example
# =============================================================================
if git diff --cached --name-only | grep -q "^\.env\.example$"; then
    echo ""
    echo -e "${RED}=========================================="
    echo "COMMIT BLOCKED: .env.example is protected"
    echo -e "==========================================${NC}"
    echo ""
    echo ".env.example should only contain placeholder values."
    echo "It must not be modified to prevent accidental credential commits."
    echo ""
    echo "To undo your changes to .env.example:"
    echo "  git restore --staged .env.example"
    echo "  git restore .env.example"
    echo ""
    echo "If you intentionally need to update the template:"
    echo "  git commit --no-verify"
    echo ""
    exit 1
fi

# =============================================================================
# BLOCK: Any .env files (except .env.example)
# =============================================================================
ENV_FILES=$(git diff --cached --name-only | grep -E '^\.env$|^\.env\.[^e]|^\.env\.local|^\.env\.production|^\.env\.development' || true)

if [ -n "$ENV_FILES" ]; then
    echo ""
    echo -e "${RED}=========================================="
    echo "COMMIT BLOCKED: .env files detected"
    echo -e "==========================================${NC}"
    echo ""
    echo "These files contain secrets and must never be committed:"
    echo "$ENV_FILES"
    echo ""
    echo "To remove from staging:"
    for f in $ENV_FILES; do
        echo "  git restore --staged $f"
    done
    echo ""
    exit 1
fi

# Patterns that indicate sensitive data
PATTERNS=(
    # Private keys
    'PRIVATE KEY'
    'BEGIN RSA'
    'BEGIN DSA'
    'BEGIN EC PRIVATE'
    'BEGIN OPENSSH PRIVATE'
    'BEGIN PGP PRIVATE'

    # Passwords and secrets in code
    'password\s*[:=]\s*["'"'"'][^"'"'"']+'
    'api[_-]?key\s*[:=]\s*["'"'"'][^"'"'"']+'
    'secret[_-]?key\s*[:=]\s*["'"'"'][^"'"'"']+'

    # AWS
    'AWS_ACCESS_KEY_ID\s*[:=]'
    'AWS_SECRET_ACCESS_KEY\s*[:=]'

    # Common API keys
    'ANTHROPIC_API_KEY\s*[:=]'
    'OPENAI_API_KEY\s*[:=]'

    # GitHub tokens
    'ghp_[A-Za-z0-9]{36}'
    'gho_[A-Za-z0-9]{36}'
    'ghu_[A-Za-z0-9]{36}'
    'ghs_[A-Za-z0-9]{36}'
    'ghr_[A-Za-z0-9]{36}'

    # Other service tokens
    'sk_live_[A-Za-z0-9]+'
    'rk_live_[A-Za-z0-9]+'
    'xox[baprs]-[A-Za-z0-9-]+'
    'SG\.[a-zA-Z0-9_-]{22}\.[a-zA-Z0-9_-]{43}'
    'npm_[A-Za-z0-9]{36}'
    'pypi-[A-Za-z0-9_-]+'

    # Credentials in URLs (any protocol)
    '://[^/:]+:[^@]+@'

    # Bearer tokens (20+ chars to reduce false positives)
    '[Bb]earer\s+[A-Za-z0-9_-]{20,}'
)

# File extensions and patterns that should never be committed
BLOCKED_EXTENSIONS=(
    '\.pem$'
    '\.key$'
    '\.p12$'
    '\.pfx$'
    '\.keystore$'
    '\.jks$'
    'id_rsa$'
    'id_dsa$'
    'id_ecdsa$'
    'id_ed25519$'
    'service[-_.]?account.*\.json$'
    'token\.json$'
    'credentials\.json$'
    'secrets\.json$'
)

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    exit 0
fi

FOUND=0

# Check for blocked file extensions
for file in $STAGED_FILES; do
    for ext in "${BLOCKED_EXTENSIONS[@]}"; do
        if [[ "$file" =~ $ext ]]; then
            echo "ERROR: Potential private key file: $file"
            echo "  Files with extension matching '$ext' should not be committed."
            echo "  Add to .gitignore or use a secrets manager."
            FOUND=1
        fi
    done
done

for file in $STAGED_FILES; do
    # Skip binary files
    if [[ "$file" =~ \.(png|jpg|gif|ico|woff|ttf|eot|pdf|zip|tar|gz|exe|dll|so|dylib)$ ]]; then
        continue
    fi

    # Skip git hooks (they contain the pattern strings they check for)
    if [[ "$file" =~ \.githooks/ ]]; then
        continue
    fi

    # Skip if file doesn't exist (deleted)
    [ -f "$file" ] || continue

    for pattern in "${PATTERNS[@]}"; do
        if grep -qiE "$pattern" "$file" 2>/dev/null; then
            echo "ERROR: Potential sensitive data in $file"
            echo "  Pattern: $pattern"
            grep -niE "$pattern" "$file" | head -3 | sed 's/^/  /'
            FOUND=1
        fi
    done
done

# =============================================================================
# BLOCK: Local network state — IP addresses, firewall rules, network commands
# =============================================================================
# These patterns catch hardcoded LAN IPs, firewall manipulation, traffic control,
# and other machine-specific network state that should not be committed.

NETWORK_PATTERNS=(
    # Private/LAN IPv4 addresses (192.168.x.x, 10.x.x.x, 172.16-31.x.x)
    '192\.168\.[0-9]+\.[0-9]+'
    '\b10\.[0-9]+\.[0-9]+\.[0-9]+'
    '172\.(1[6-9]|2[0-9]|3[01])\.[0-9]+\.[0-9]+'

    # Firewall manipulation
    '\biptables\b'
    '\bip6tables\b'
    '\bnftables\b'
    '\bnft\b'
    '\bpfctl\b'
    '\bufw\b'
    '\bfirewall-cmd\b'

    # Traffic control / network emulation
    '\btc qdisc\b'
    '\btc class\b'
    '\btc filter\b'
    '\bnetem\b'

    # Interface / routing manipulation
    '\bip addr add\b'
    '\bip addr del\b'
    '\bip route add\b'
    '\bip route del\b'
    '\bifconfig\b.*\b(up|down|add|delete)\b'

    # SSH to specific hosts (machine-specific orchestration)
    '\bssh\s+\S+\s+"?sudo\b'

    # Machine-specific hostnames and paths
    '\b(enP[0-9]s[0-9]|eth[0-9]|wlan[0-9])\b'
)

# RFC 5737 documentation IPs that are safe to use in code:
#   192.0.2.0/24 (TEST-NET-1), 198.51.100.0/24 (TEST-NET-2), 203.0.113.0/24 (TEST-NET-3)
# These are excluded from the private IP checks below.
SAFE_IP_EXCLUDE='192\.0\.2\.|198\.51\.100\.|203\.0\.113\.'

for file in $STAGED_FILES; do
    # Skip binary files
    if [[ "$file" =~ \.(png|jpg|gif|ico|woff|ttf|eot|pdf|zip|tar|gz|exe|dll|so|dylib)$ ]]; then
        continue
    fi

    # Skip git hooks themselves
    if [[ "$file" =~ \.githooks/ ]]; then
        continue
    fi

    # Skip if file doesn't exist (deleted)
    [ -f "$file" ] || continue

    for pattern in "${NETWORK_PATTERNS[@]}"; do
        # For IP address patterns, exclude RFC 5737 documentation IPs
        if [[ "$pattern" == *'192\.'* ]] || [[ "$pattern" == *'10\.'* ]] || [[ "$pattern" == *'172\.'* ]]; then
            MATCHES=$(grep -nE "$pattern" "$file" 2>/dev/null | grep -vE "$SAFE_IP_EXCLUDE" || true)
        else
            MATCHES=$(grep -nE "$pattern" "$file" 2>/dev/null || true)
        fi
        if [ -n "$MATCHES" ]; then
            echo "ERROR: Local network state in $file"
            echo "  Pattern: $pattern"
            echo "  Scripts with machine-specific network state should not be committed."
            echo "  For examples/docs, use RFC 5737 IPs: 192.0.2.x, 198.51.100.x, 203.0.113.x"
            echo "$MATCHES" | head -3 | sed 's/^/  /'
            FOUND=1
        fi
    done
done

# =============================================================================
# BLOCK: Absolute paths — machine-specific filesystem references
# =============================================================================
# Absolute paths tie code to a specific machine layout and should be avoided
# in committed code. Use relative paths or environment variables instead.

ABSPATH_PATTERNS=(
    # Unix absolute paths (but not common system paths used in shebangs/includes)
    '/home/[a-zA-Z0-9_]+'
    '/Users/[a-zA-Z0-9_]+'
    '/tmp/[a-zA-Z0-9_]+'
    '/var/[a-zA-Z0-9_]+/[a-zA-Z0-9_]+'
    '/opt/[a-zA-Z0-9_]+/[a-zA-Z0-9_]+'
)

# Lines to exclude (shebangs, comments referencing standard paths, build system)
ABSPATH_EXCLUDE='(^#!|^[0-9]+:[[:space:]]*(#|//|/\*)|/usr/bin|/usr/lib|/usr/local|/usr/share|Package\.resolved|\.build/)'

for file in $STAGED_FILES; do
    # Skip binary files
    if [[ "$file" =~ \.(png|jpg|gif|ico|woff|ttf|eot|pdf|zip|tar|gz|exe|dll|so|dylib)$ ]]; then
        continue
    fi

    # Skip git hooks themselves (they legitimately use $REPO_ROOT etc.)
    if [[ "$file" =~ \.githooks/ ]]; then
        continue
    fi

    # Skip if file doesn't exist (deleted)
    [ -f "$file" ] || continue

    for pattern in "${ABSPATH_PATTERNS[@]}"; do
        # Find matches, then exclude known-safe lines
        MATCHES=$(grep -nE "$pattern" "$file" 2>/dev/null | grep -vE "$ABSPATH_EXCLUDE" || true)
        if [ -n "$MATCHES" ]; then
            echo "ERROR: Absolute path in $file"
            echo "  Pattern: $pattern"
            echo "  Use relative paths or environment variables instead."
            echo "$MATCHES" | head -3 | sed 's/^/  /'
            FOUND=1
        fi
    done
done

if [ $FOUND -eq 1 ]; then
    echo ""
    echo "Commit blocked. Remove sensitive data or use: git commit --no-verify"
    exit 1
fi

exit 0
