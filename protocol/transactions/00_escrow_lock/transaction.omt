# Transaction 00: Escrow Lock / Top-up
# SINGLE SOURCE OF TRUTH
#
# This file defines all parameters, messages, and state machines for the
# escrow lock transaction. Both documentation and Python code are generated
# from this schema.

transaction 00 "Escrow Lock / Top-up" "Lock funds with distributed witness consensus for a compute session"

imports shared/common

# =============================================================================
# PARAMETERS
# =============================================================================

parameters (
    # Witness counts
    WITNESS_COUNT = 5 count "Initial witnesses to recruit"
    WITNESS_THRESHOLD = 3 count "Minimum for consensus"

    # Timeouts (seconds)
    WITNESS_COMMITMENT_TIMEOUT = 30 seconds "Seconds for provider to respond with witnesses"
    LOCK_TIMEOUT = 300 seconds "Seconds for consumer to complete lock (provider waiting)"
    PRELIMINARY_TIMEOUT = 30 seconds "Seconds to collect preliminaries"
    CONSENSUS_TIMEOUT = 60 seconds "Seconds to reach consensus"
    RECRUITMENT_TIMEOUT = 180 seconds "Seconds for full recruitment"
    CONSUMER_SIGNATURE_TIMEOUT = 60 seconds "Seconds for consumer to counter-sign"
    LIVENESS_CHECK_INTERVAL = 300 seconds "Seconds between liveness checks"
    LIVENESS_RESPONSE_TIMEOUT = 30 seconds "Seconds to respond to ping"
    REPLACEMENT_TIMEOUT = 120 seconds "Seconds to get replacement witness ack"
    MAX_CHAIN_AGE = 3600 seconds "Max age of chain knowledge"

    # Thresholds
    CONSENSUS_THRESHOLD = 0.67 fraction "Fraction needed to decide"

    # Limits
    MAX_RECRUITMENT_ROUNDS = 3 count "Max times to recruit more witnesses"
    MIN_HIGH_TRUST_WITNESSES = 2 count "Minimum high-trust witnesses for fairness"
    MAX_PRIOR_INTERACTIONS = 5 count "Max prior interactions with consumer for fairness"
    HIGH_TRUST_THRESHOLD = 1.0 fraction "Trust score threshold for high-trust classification"
)

# =============================================================================
# ENUMS
# =============================================================================

enum WitnessVerdict "Witness verdict on lock request" (
    ACCEPT
    REJECT
    NEED_MORE_INFO
)

enum LockStatus "Final status of lock attempt" (
    ACCEPTED
    REJECTED
    CONSUMER_ABANDONED
)

# =============================================================================
# BLOCK TYPES (written to chain)
# =============================================================================

block BALANCE_LOCK by [Consumer, Witness] (
    session_id       hash
    amount           uint
    lock_result_hash hash
    timestamp        timestamp
)

block BALANCE_TOPUP by [Consumer, Witness] (
    session_id       hash
    previous_total   uint
    topup_amount     uint
    new_total        uint
    topup_result_hash hash
    timestamp        timestamp
)

block WITNESS_COMMITMENT by [Witness] (
    session_id       hash
    consumer         peer_id
    provider         peer_id
    amount           uint
    observed_balance uint
    witnesses        list<peer_id>
    timestamp        timestamp
)

block WITNESS_REPLACEMENT by [Witness] (
    session_id          hash
    old_witness         peer_id
    new_witness         peer_id
    reason              string
    remaining_witnesses list<peer_id>
    timestamp           timestamp
)

# =============================================================================
# MESSAGES
# =============================================================================

# --- Consumer -> Provider ---
message LOCK_INTENT from Consumer to [Provider] signed (
    consumer                   peer_id
    provider                   peer_id
    amount                     uint
    session_id                 hash
    consumer_nonce             bytes
    provider_chain_checkpoint  hash
    checkpoint_timestamp       timestamp
    timestamp                  timestamp
)

# --- Provider -> Consumer ---
message WITNESS_SELECTION_COMMITMENT from Provider to [Consumer] signed (
    session_id             hash
    provider               peer_id
    provider_nonce         bytes
    provider_chain_segment bytes
    selection_inputs       SelectionInputs
    witnesses              list<peer_id>
    timestamp              timestamp
)

message LOCK_REJECTED from Provider to [Consumer] signed (
    session_id  hash
    reason      string
    timestamp   timestamp
)

# --- Consumer -> Witnesses ---
message WITNESS_REQUEST from Consumer to [Witness] signed (
    consumer      peer_id
    provider      peer_id
    amount        uint
    session_id    hash
    my_chain_head hash
    witnesses     list<peer_id>
    timestamp     timestamp
)

message CONSUMER_SIGNED_LOCK from Consumer to [Witness] (
    session_id         hash
    consumer_signature signature
    timestamp          timestamp
)

# --- Witness <-> Witness ---
message WITNESS_PRELIMINARY from Witness to [Witness] signed (
    session_id          hash
    witness             peer_id
    verdict             WitnessVerdict
    observed_balance    uint
    observed_chain_head hash
    reject_reason       string
    timestamp           timestamp
)

message WITNESS_CHAIN_SYNC_REQUEST from Witness to [Witness] signed (
    session_id          hash
    consumer            peer_id
    requesting_witness  peer_id
    timestamp           timestamp
)

message WITNESS_CHAIN_SYNC_RESPONSE from Witness to [Witness] signed (
    session_id  hash
    consumer    peer_id
    chain_data  bytes
    chain_head  hash
    timestamp   timestamp
)

message WITNESS_FINAL_VOTE from Witness to [Witness] signed (
    session_id       hash
    witness          peer_id
    vote             WitnessVerdict
    observed_balance uint
    timestamp        timestamp
)

message WITNESS_RECRUIT_REQUEST from Witness to [Witness] signed (
    session_id         hash
    consumer           peer_id
    provider           peer_id
    amount             uint
    existing_witnesses list<peer_id>
    existing_votes     list<WITNESS_FINAL_VOTE>
    reason             string
    timestamp          timestamp
)

# --- Witness -> Consumer ---
message LOCK_RESULT_FOR_SIGNATURE from Witness to [Consumer] (
    result  LockResult
)

# --- Witness -> Network ---
message BALANCE_UPDATE_BROADCAST from Witness to [Network] (
    consumer     peer_id
    lock_result  LockResult
    timestamp    timestamp
)

# --- Liveness ---
message LIVENESS_PING from Witness to [Witness, Consumer] signed (
    session_id    hash
    from_witness  peer_id
    timestamp     timestamp
)

message LIVENESS_PONG from Witness to [Witness] signed (
    session_id    hash
    from_witness  peer_id
    timestamp     timestamp
)

# --- Top-up ---
message TOPUP_INTENT from Consumer to [Witness] signed (
    session_id               hash
    consumer                 peer_id
    additional_amount        uint
    current_lock_result_hash hash
    timestamp                timestamp
)

message TOPUP_RESULT_FOR_SIGNATURE from Witness to [Consumer] (
    topup_result  TopUpResult
)

message CONSUMER_SIGNED_TOPUP from Consumer to [Witness] (
    session_id         hash
    consumer_signature signature
    timestamp          timestamp
)

message TOPUP_VOTE from Witness to [Witness] signed (
    session_id        hash
    witness           peer_id
    vote              WitnessVerdict
    additional_amount uint
    observed_balance  uint
    timestamp         timestamp
)

# =============================================================================
# FUNCTIONS (Transaction-specific)
# =============================================================================

function COMPUTE_ESCROW_CONSENSUS(preliminaries list<dict>) -> string (
    # Start with this witness's own verdict (enum comparison)
    my_verdict = LOAD(verdict)
    accept_count = IF my_verdict == WitnessVerdict.ACCEPT THEN 1 ELSE 0
    # Count verdicts from other witnesses (serialized as string)
    FOR p IN preliminaries
        accept_count = IF p.verdict == "ACCEPT" THEN accept_count + 1 ELSE accept_count
    # Need threshold for acceptance
    RETURN IF accept_count >= WITNESS_THRESHOLD THEN "ACCEPT" ELSE "REJECT"
)

function BUILD_LOCK_RESULT() -> LockResult (
    consensus = LOAD(consensus_direction)
    status = IF consensus == "ACCEPT" THEN LockStatus.ACCEPTED ELSE LockStatus.REJECTED
    votes = LOAD(votes)
    signatures = MAP(votes, v => v.signature)
    RETURN {
        session_id LOAD(session_id),
        consumer LOAD(consumer),
        provider LOAD(provider),
        amount LOAD(amount),
        status status,
        observed_balance LOAD(observed_balance),
        witnesses LOAD(witnesses),
        witness_signatures signatures,
        consumer_signature null,
        timestamp NOW()
    }
)

function BUILD_TOPUP_RESULT() -> TopUpResult (
    consensus = LOAD(topup_consensus_direction)
    status = IF consensus == "ACCEPT" THEN LockStatus.ACCEPTED ELSE LockStatus.REJECTED
    votes = LOAD(topup_votes)
    signatures = MAP(votes, v => v.signature)
    RETURN {
        session_id LOAD(session_id),
        consumer LOAD(consumer),
        provider LOAD(provider),
        previous_total LOAD(total_escrowed),
        additional_amount LOAD(topup_intent).additional_amount,
        new_total LOAD(total_escrowed) + LOAD(topup_intent).additional_amount,
        observed_balance LOAD(topup_observed_balance),
        witnesses LOAD(witnesses),
        witness_signatures signatures,
        consumer_signature null,
        timestamp NOW()
    }
)

function VALIDATE_LOCK_RESULT(result dict, expected_session_id hash, expected_amount uint) -> bool (
    # Validate lock result matches expected values and has ACCEPTED status
    valid_session = result != null AND result.session_id == expected_session_id
    valid_amount = result != null AND result.amount == expected_amount
    valid_status = result != null AND (result.status == LockStatus.ACCEPTED OR result.status == "ACCEPTED")
    has_sigs = result != null AND LENGTH(result.witness_signatures) > 0
    RETURN valid_session AND valid_amount AND valid_status AND has_sigs
)

function VALIDATE_TOPUP_RESULT(result dict, expected_session_id hash, expected_additional_amount uint) -> bool (
    # Validate topup result matches expected values
    valid_session = result != null AND result.session_id == expected_session_id
    valid_amount = result != null AND result.additional_amount == expected_additional_amount
    has_sigs = result != null AND LENGTH(result.witness_signatures) > 0
    RETURN valid_session AND valid_amount AND has_sigs
)

function VERIFY_WITNESS_SELECTION(proposed_witnesses list<peer_id>, chain_state dict, session_id hash, provider_nonce bytes, consumer_nonce bytes) -> bool (
    # Recompute expected witnesses from seed and compare
    seed = HASH(session_id, provider_nonce, consumer_nonce)
    expected = SELECT_WITNESSES(seed, chain_state)
    RETURN SET_EQUALS(proposed_witnesses, expected)
)

function SELECT_WITNESSES(seed bytes, chain_state dict) -> list<peer_id> (
    # Get candidates from chain state, excluding self, consumer, provider
    known_peers = chain_state.known_peers
    consumer = LOAD(consumer)
    provider = LOAD(provider)
    candidates = FILTER(known_peers, p => p != peer_id AND p != consumer AND p != provider)

    # Sort deterministically
    candidates = SORT(candidates)

    # Separate by trust level
    trust_scores = chain_state.trust_scores
    high_trust = FILTER(candidates, c => GET(trust_scores, c, 0) >= HIGH_TRUST_THRESHOLD)
    low_trust = FILTER(candidates, c => GET(trust_scores, c, 0) < HIGH_TRUST_THRESHOLD)

    # Seeded selection
    rng = SEEDED_RNG(seed)
    selected = []

    # Select required high-trust witnesses
    ht_sample = MIN(MIN_HIGH_TRUST_WITNESSES, LENGTH(high_trust))
    selected = SEEDED_SAMPLE(rng, high_trust, ht_sample)

    # Fill remaining slots from all candidates
    remaining = FILTER(candidates, c => NOT CONTAINS(selected, c))
    needed = WITNESS_COUNT - LENGTH(selected)
    additional = SEEDED_SAMPLE(rng, remaining, needed)

    RETURN CONCAT(selected, additional)
)

# =============================================================================
# ACTORS
# =============================================================================

actor Consumer "Party paying for service" (
    store (
        provider                 peer_id
        amount                   uint
        session_id               hash
        consumer_nonce           bytes
        provider_chain_checkpoint hash
        checkpoint_timestamp     timestamp
        provider_nonce           bytes
        provider_chain_segment   bytes
        selection_inputs         SelectionInputs
        proposed_witnesses       list<peer_id>
        verified_chain_state     ChainState
        witnesses                list<peer_id>
        intent_sent_at           timestamp
        requests_sent_at         timestamp
        pending_result           LockResult
        result_sender            peer_id
        lock_result              LockResult
        reject_reason            string
        total_escrowed           uint
        additional_amount        uint
        current_lock_hash        hash
        topup_sent_at            timestamp
        pending_topup_result     TopUpResult
        topup_result             TopUpResult
        topup_failed_reason      string
    )

    trigger initiate_lock(provider peer_id, amount uint) in [IDLE] "Start a new escrow lock"
    trigger initiate_topup(additional_amount uint) in [LOCKED] "Add funds to existing escrow"

    state IDLE initial "Waiting to initiate lock"
    state SENDING_LOCK_INTENT "Sending lock intent to provider"
    state WAITING_FOR_WITNESS_COMMITMENT "Waiting for provider witness selection"
    state VERIFYING_PROVIDER_CHAIN "Verifying provider's chain segment"
    state VERIFYING_WITNESSES "Verifying witness selection is correct"
    state SENDING_REQUESTS "Sending requests to witnesses"
    state WAITING_FOR_RESULT "Waiting for witness consensus"
    state REVIEWING_RESULT "Reviewing lock result"
    state SIGNING_RESULT "Counter-signing the lock"
    state LOCKED "Funds successfully locked"
    state FAILED terminal "Lock failed"
    state SENDING_TOPUP "Sending top-up request"
    state WAITING_FOR_TOPUP_RESULT "Waiting for cabal top-up consensus"
    state REVIEWING_TOPUP_RESULT "Reviewing top-up result"
    state SIGNING_TOPUP "Counter-signing top-up"

    # Initial lock flow
    IDLE -> SENDING_LOCK_INTENT on initiate_lock when provider_chain_checkpoint != null (
        store provider, amount
        STORE(consumer, peer_id)
        session_id = HASH(peer_id + provider + NOW())
        consumer_nonce = RANDOM_BYTES(32)
        provider_chain_checkpoint = READ(provider, "head_hash")
    ) else -> FAILED (
        store provider, amount
        STORE(consumer, peer_id)
        STORE(reject_reason, "no_prior_provider_checkpoint")
    )

    SENDING_LOCK_INTENT -> WAITING_FOR_WITNESS_COMMITMENT auto (
        SEND(provider, LOCK_INTENT)
        STORE(intent_sent_at, NOW())
    )

    WAITING_FOR_WITNESS_COMMITMENT -> VERIFYING_PROVIDER_CHAIN on WITNESS_SELECTION_COMMITMENT (
        store provider_nonce, provider_chain_segment, selection_inputs
        STORE(proposed_witnesses, message.witnesses)
        chain_segment_valid_and_contains_checkpoint = VERIFY_CHAIN_SEGMENT(provider_chain_segment) AND CHAIN_CONTAINS_HASH(provider_chain_segment, provider_chain_checkpoint)
    )

    WAITING_FOR_WITNESS_COMMITMENT -> FAILED on LOCK_REJECTED (
        STORE(reject_reason, message.reason)
    )

    WAITING_FOR_WITNESS_COMMITMENT -> FAILED on timeout(WITNESS_COMMITMENT_TIMEOUT) (
        STORE(reject_reason, "provider_timeout")
    )

    VERIFYING_PROVIDER_CHAIN -> VERIFYING_WITNESSES auto when chain_segment_valid_and_contains_checkpoint (
        verified_chain_state = CHAIN_STATE_AT(provider_chain_segment, provider_chain_checkpoint)
        witness_selection_valid = VERIFY_WITNESS_SELECTION(proposed_witnesses, selection_inputs, session_id, provider_nonce, consumer_nonce)
    )

    VERIFYING_WITNESSES -> SENDING_REQUESTS auto when witness_selection_valid (
        STORE(witnesses, proposed_witnesses)
    )

    SENDING_REQUESTS -> WAITING_FOR_RESULT auto (
        BROADCAST(witnesses, WITNESS_REQUEST)
        STORE(requests_sent_at, NOW())
    )

    WAITING_FOR_RESULT -> REVIEWING_RESULT on LOCK_RESULT_FOR_SIGNATURE (
        STORE(pending_result, message.result)
        STORE(result_sender, message.sender)
        result_valid_and_accepted = VALIDATE_LOCK_RESULT(pending_result, session_id, amount)
    )

    WAITING_FOR_RESULT -> FAILED on timeout(RECRUITMENT_TIMEOUT) (
        STORE(reject_reason, "witness_timeout")
    )

    REVIEWING_RESULT -> SIGNING_RESULT auto when result_valid_and_accepted

    REVIEWING_RESULT -> FAILED auto when NOT result_valid_and_accepted (
        STORE(reject_reason, "lock_rejected")
    )

    SIGNING_RESULT -> LOCKED auto (
        consumer_signature = SIGN(pending_result)
        STORE(lock_result, {...pending_result, consumer_signature consumer_signature})
        APPEND(chain, BALANCE_LOCK)
        BROADCAST(witnesses, CONSUMER_SIGNED_LOCK)
        STORE(total_escrowed, amount)
    )

    # Locked state transitions
    LOCKED -> LOCKED on LIVENESS_PING (
        STORE(from_witness, peer_id)
        SEND(message.sender, LIVENESS_PONG)
    )

    LOCKED -> SENDING_TOPUP on initiate_topup (
        store additional_amount
        current_lock_hash = HASH(lock_result)
    )

    # Top-up flow
    SENDING_TOPUP -> WAITING_FOR_TOPUP_RESULT auto (
        BROADCAST(witnesses, TOPUP_INTENT)
        STORE(topup_sent_at, NOW())
    )

    WAITING_FOR_TOPUP_RESULT -> REVIEWING_TOPUP_RESULT on TOPUP_RESULT_FOR_SIGNATURE (
        STORE(pending_topup_result, message.topup_result)
        topup_result_valid = VALIDATE_TOPUP_RESULT(pending_topup_result, session_id, additional_amount)
    )

    WAITING_FOR_TOPUP_RESULT -> LOCKED on timeout(CONSENSUS_TIMEOUT) (
        STORE(topup_failed_reason, "timeout")
    )

    REVIEWING_TOPUP_RESULT -> SIGNING_TOPUP auto when topup_result_valid

    SIGNING_TOPUP -> LOCKED auto (
        consumer_signature = SIGN(pending_topup_result)
        STORE(topup_result, {...pending_topup_result, consumer_signature consumer_signature})
        APPEND(chain, BALANCE_TOPUP)
        BROADCAST(witnesses, CONSUMER_SIGNED_TOPUP)
        STORE(total_escrowed, total_escrowed + additional_amount)
    )
)

actor Provider "Party providing service, selects witnesses" (
    store (
        consumer                   peer_id
        amount                     uint
        session_id                 hash
        consumer_nonce             bytes
        provider_nonce             bytes
        requested_checkpoint       hash
        checkpoint_timestamp       timestamp
        chain_state_at_checkpoint  ChainState
        provider_chain_segment     bytes
        witnesses                  list<peer_id>
        selection_inputs           SelectionInputs
        commitment_sent_at         timestamp
        lock_result                LockResult
        reason                     string
    )

    state IDLE initial "Waiting for lock request"
    state VALIDATING_CHECKPOINT "Validating consumer's checkpoint reference"
    state SENDING_REJECTION "Sending rejection due to invalid checkpoint"
    state SELECTING_WITNESSES "Computing deterministic witness selection"
    state SENDING_COMMITMENT "Sending witness selection to consumer"
    state WAITING_FOR_LOCK "Waiting for lock to complete"
    state SERVICE_PHASE terminal "Lock complete, providing service"

    IDLE -> VALIDATING_CHECKPOINT on LOCK_INTENT (
        store consumer, amount, session_id, consumer_nonce
        STORE(requested_checkpoint, message.provider_chain_checkpoint)
        provider_nonce = RANDOM_BYTES(32)
    )

    VALIDATING_CHECKPOINT -> SELECTING_WITNESSES auto when CHAIN_CONTAINS_HASH(chain, requested_checkpoint) (
        chain_state_at_checkpoint = CHAIN_STATE_AT(chain, requested_checkpoint)
        provider_chain_segment = CHAIN_SEGMENT(chain, requested_checkpoint)
    ) else -> SENDING_REJECTION (
        STORE(reason, "unknown_checkpoint")
    )

    SENDING_REJECTION -> IDLE auto (
        SEND(consumer, LOCK_REJECTED)
    )

    SELECTING_WITNESSES -> SENDING_COMMITMENT auto (
        witnesses = SELECT_WITNESSES(HASH(session_id + provider_nonce + consumer_nonce), chain_state_at_checkpoint)
        STORE(selection_inputs, chain_state_at_checkpoint)
    )

    SENDING_COMMITMENT -> WAITING_FOR_LOCK auto (
        SEND(consumer, WITNESS_SELECTION_COMMITMENT)
        STORE(commitment_sent_at, NOW())
    )

    WAITING_FOR_LOCK -> SERVICE_PHASE on BALANCE_UPDATE_BROADCAST when message.lock_result.session_id == session_id and message.lock_result.status == ACCEPTED (
        STORE(lock_result, message.lock_result)
    )

    WAITING_FOR_LOCK -> IDLE on timeout(LOCK_TIMEOUT) (
        STORE(session_id, null)
    )
)

actor Witness "Verifies consumer balance, participates in consensus" (
    store (
        request                  WitnessRequest
        consumer                 peer_id
        provider                 peer_id
        amount                   uint
        session_id               hash
        my_chain_head            hash
        witnesses                list<peer_id>
        other_witnesses          list<peer_id>
        last_seen_record         ChainRecord
        peer_balances            map<peer_id, uint>
        observed_balance         uint
        observed_chain_head      hash
        reject_reason            string
        verdict                  WitnessVerdict
        preliminaries            list<WitnessPreliminary>
        votes                    list<WitnessFinalVote>
        signatures               list<signature>
        recruitment_round        uint
        consensus_direction      string
        final_result             LockStatus
        result                   LockResult
        total_escrowed           uint
        topup_intent             TopUpIntent
        topup_observed_balance   uint
        topup_free_balance       uint
        topup_verdict            WitnessVerdict
        topup_votes              list<TopUpVote>
        topup_signatures         list<signature>
        topup_final_result       LockStatus
        topup_result             TopUpResult
    )

    state IDLE initial "Waiting for witness request"
    state CHECKING_CHAIN_KNOWLEDGE "Checking if we have recent consumer chain data"
    state CHECKING_BALANCE "Verifying consumer has sufficient balance"
    state CHECKING_EXISTING_LOCKS "Checking for existing locks on balance"
    state SHARING_PRELIMINARY "Sharing preliminary verdict with peers"
    state COLLECTING_PRELIMINARIES "Collecting preliminary verdicts"
    state VOTING "Casting final vote"
    state COLLECTING_VOTES "Collecting final votes"
    state BUILDING_RESULT "Building final lock result"
    state SIGNING_RESULT "Signing the lock result"
    state PROPAGATING_RESULT "Sending result to consumer"
    state ESCROW_ACTIVE "Escrow locked, monitoring liveness"
    state DONE terminal "Lock process complete"
    state CHECKING_TOPUP_BALANCE "Verifying consumer has additional free balance"
    state VOTING_TOPUP "Voting on top-up request"
    state COLLECTING_TOPUP_VOTES "Collecting top-up votes from other witnesses"
    state BUILDING_TOPUP_RESULT "Building the top-up result after consensus"
    state PROPAGATING_TOPUP "Sending top-up result to consumer for signature"

    IDLE -> CHECKING_CHAIN_KNOWLEDGE on WITNESS_REQUEST (
        store consumer, provider, amount, session_id, my_chain_head, witnesses
        STORE(consumer, message.sender)
        other_witnesses = REMOVE(witnesses, peer_id)
        STORE(preliminaries, [])
        STORE(votes, [])
        STORE(signatures, [])
        STORE(recruitment_round, 0)
    )

    CHECKING_CHAIN_KNOWLEDGE -> CHECKING_BALANCE auto (
        observed_balance = peer_balances[consumer]
    )

    CHECKING_BALANCE -> CHECKING_EXISTING_LOCKS auto when observed_balance >= amount

    CHECKING_BALANCE -> SHARING_PRELIMINARY auto when observed_balance < amount (
        STORE(verdict, REJECT)
        STORE(reject_reason, "insufficient_balance")
    )

    CHECKING_EXISTING_LOCKS -> SHARING_PRELIMINARY auto (
        STORE(verdict, ACCEPT)
    )

    SHARING_PRELIMINARY -> COLLECTING_PRELIMINARIES auto (
        BROADCAST(other_witnesses, WITNESS_PRELIMINARY)
        STORE(preliminary_sent_at, NOW())
    )

    COLLECTING_PRELIMINARIES -> COLLECTING_PRELIMINARIES on WITNESS_PRELIMINARY (
        APPEND(preliminaries, message.payload)
    )

    # Fast path: advance when enough preliminaries collected
    COLLECTING_PRELIMINARIES -> VOTING auto when LENGTH(preliminaries) >= WITNESS_THRESHOLD - 1 (
        consensus_direction = COMPUTE_ESCROW_CONSENSUS(preliminaries)
    )

    # Timeout fallback
    COLLECTING_PRELIMINARIES -> VOTING on timeout(PRELIMINARY_TIMEOUT) (
        consensus_direction = COMPUTE_ESCROW_CONSENSUS(preliminaries)
    )

    VOTING -> COLLECTING_VOTES auto (
        BROADCAST(other_witnesses, WITNESS_FINAL_VOTE)
    )

    COLLECTING_VOTES -> COLLECTING_VOTES on WITNESS_FINAL_VOTE (
        APPEND(votes, message.payload)
    )

    # Fast path: advance when enough votes collected
    COLLECTING_VOTES -> BUILDING_RESULT auto when LENGTH(votes) >= WITNESS_THRESHOLD

    # Timeout fallback
    COLLECTING_VOTES -> BUILDING_RESULT on timeout(CONSENSUS_TIMEOUT) when LENGTH(votes) >= WITNESS_THRESHOLD

    BUILDING_RESULT -> SIGNING_RESULT auto (
        result = BUILD_LOCK_RESULT()
    )

    SIGNING_RESULT -> PROPAGATING_RESULT auto (
        SEND(consumer, LOCK_RESULT_FOR_SIGNATURE)
        STORE(propagated_at, NOW())
    )

    PROPAGATING_RESULT -> ESCROW_ACTIVE on CONSUMER_SIGNED_LOCK (
        STORE(consumer_signature, message.signature)
        STORE(total_escrowed, amount)
        APPEND(chain, WITNESS_COMMITMENT)
        SEND(provider, BALANCE_UPDATE_BROADCAST)
    )

    PROPAGATING_RESULT -> DONE on timeout(CONSENSUS_TIMEOUT) (
        STORE(reject_reason, "consumer_signature_timeout")
    )

    ESCROW_ACTIVE -> CHECKING_TOPUP_BALANCE on TOPUP_INTENT (
        STORE(topup_intent, message)
        topup_observed_balance = peer_balances[consumer]
    )

    # Top-up balance check - accept if sufficient free balance
    CHECKING_TOPUP_BALANCE -> VOTING_TOPUP auto when topup_observed_balance - total_escrowed >= topup_intent.additional_amount (
        STORE(topup_verdict, accept)
    )

    # Top-up balance check - reject if insufficient
    CHECKING_TOPUP_BALANCE -> ESCROW_ACTIVE auto when topup_observed_balance - total_escrowed < topup_intent.additional_amount (
        STORE(topup_verdict, reject)
        STORE(topup_reject_reason, "insufficient_free_balance")
    )

    VOTING_TOPUP -> COLLECTING_TOPUP_VOTES auto (
        STORE(topup_votes, [])
        BROADCAST(other_witnesses, TOPUP_VOTE)
    )

    COLLECTING_TOPUP_VOTES -> COLLECTING_TOPUP_VOTES on TOPUP_VOTE (
        APPEND(topup_votes, message.payload)
    )

    # Fast path - need WITNESS_THRESHOLD total (including own vote added in VOTING_TOPUP)
    COLLECTING_TOPUP_VOTES -> BUILDING_TOPUP_RESULT auto when LENGTH(topup_votes) >= WITNESS_THRESHOLD

    # Timeout fallback
    COLLECTING_TOPUP_VOTES -> BUILDING_TOPUP_RESULT on timeout(PRELIMINARY_TIMEOUT) when LENGTH(topup_votes) >= WITNESS_THRESHOLD

    COLLECTING_TOPUP_VOTES -> ESCROW_ACTIVE on timeout(CONSENSUS_TIMEOUT) (
        STORE(topup_failed_reason, "vote_timeout")
    )

    BUILDING_TOPUP_RESULT -> PROPAGATING_TOPUP auto (
        topup_result = BUILD_TOPUP_RESULT()
        SEND(consumer, TOPUP_RESULT_FOR_SIGNATURE)
    )

    PROPAGATING_TOPUP -> ESCROW_ACTIVE on CONSUMER_SIGNED_TOPUP (
        STORE(total_escrowed, total_escrowed + topup_intent.additional_amount)
    )

    PROPAGATING_TOPUP -> ESCROW_ACTIVE on timeout(CONSENSUS_TIMEOUT) (
        STORE(topup_failed_reason, "consumer_signature_timeout")
    )

    ESCROW_ACTIVE -> ESCROW_ACTIVE on LIVENESS_PING (
        STORE(from_witness, peer_id)
        SEND(message.sender, LIVENESS_PONG)
    )
)
