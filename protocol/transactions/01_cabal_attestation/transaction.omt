# Transaction 01: Cabal Attestation
# SINGLE SOURCE OF TRUTH
#
# This file defines all parameters, messages, and state machines for the
# cabal attestation transaction. Both documentation and Python code are generated
# from this schema.

transaction 01 "Cabal Attestation" "Witnesses verify VM allocation, monitor session, and attest to service delivery"

imports shared/common

# =============================================================================
# PARAMETERS
# =============================================================================

parameters (
    # Verification timeouts
    VM_ALLOCATION_TIMEOUT = 300 seconds "Provider must allocate VM within 5 min of lock"
    CONNECTIVITY_CHECK_TIMEOUT = 60 seconds "Witnesses must verify connectivity within 1 min"
    CONNECTIVITY_VOTE_TIMEOUT = 30 seconds "Time to collect connectivity votes"
    ABORT_VOTE_TIMEOUT = 30 seconds "Time to collect abort votes"

    # Monitoring parameters
    MONITORING_CHECK_INTERVAL = 60 seconds "Periodic VM health check interval"
    MISUSE_INVESTIGATION_TIMEOUT = 120 seconds "Time to investigate misuse accusation"

    # Thresholds
    CONNECTIVITY_THRESHOLD = 0.67 fraction "Fraction of witnesses that must verify connectivity"
    ABORT_THRESHOLD = 0.67 fraction "Fraction needed to abort session"
    ATTESTATION_THRESHOLD = 3 count "Minimum witnesses for valid attestation"

    # Witness selection parameters
    WITNESS_COUNT = 5 count "Number of witnesses (from escrow lock)"
    MIN_HIGH_TRUST_WITNESSES = 2 count "Minimum high-trust witnesses required"
    MAX_PRIOR_INTERACTIONS = 3 count "Maximum prior interactions with witness"
)

# =============================================================================
# ENUMS
# =============================================================================

enum TerminationReason "Reasons for session termination" (
    COMPLETED_NORMAL       # Session ran full duration
    CONSUMER_REQUEST       # Consumer asked to stop early
    PROVIDER_VOLUNTARY     # Provider chose to stop
    VM_DIED               # VM crashed or became unreachable
    TIMEOUT               # Session exceeded max duration
    CONSUMER_MISUSE       # Consumer violated terms
    ALLOCATION_FAILED     # VM couldn't be allocated
    CONNECTIVITY_FAILED   # Cabal couldn't verify VM
)

# =============================================================================
# BLOCK TYPES (written to chain)
# =============================================================================

block ATTESTATION by [Witness] (
    session_id              hash
    connectivity_verified   bool
    actual_duration_seconds uint
    termination_reason      string
    witnesses               list<peer_id>
    timestamp               timestamp
)

# =============================================================================
# MESSAGES
# =============================================================================

# --- Provider -> Witnesses ---
message VM_ALLOCATED from Provider to [Witness] signed (
    session_id                  hash
    provider                    peer_id
    consumer                    peer_id
    vm_wireguard_pubkey         bytes
    consumer_wireguard_endpoint string
    cabal_wireguard_endpoints   list<string>
    allocated_at                timestamp
    lock_result_hash            hash
    timestamp                   timestamp
)

message VM_CANCELLED from Provider to [Witness] signed (
    session_id              hash
    provider                peer_id
    cancelled_at            timestamp
    reason                  TerminationReason
    actual_duration_seconds uint
    timestamp               timestamp
)

message MISUSE_ACCUSATION from Provider to [Witness] signed (
    session_id  hash
    provider    peer_id
    evidence    string
    timestamp   timestamp
)

# --- Provider -> Consumer ---
message VM_READY from Provider to [Consumer] (
    session_id  hash
    vm_info     dict
    timestamp   timestamp
)

message SESSION_TERMINATED from Provider to [Consumer] (
    session_id  hash
    reason      TerminationReason
    timestamp   timestamp
)

# --- Consumer -> Provider ---
message CANCEL_REQUEST from Consumer to [Provider] signed (
    session_id  hash
    consumer    peer_id
    timestamp   timestamp
)

# --- Witness <-> Witness ---
message VM_CONNECTIVITY_VOTE from Witness to [Witness, Provider] signed (
    session_id                  hash
    witness                     peer_id
    can_reach_vm                bool
    can_see_consumer_connected  bool
    timestamp                   timestamp
)

message ABORT_VOTE from Witness to [Witness] signed (
    session_id  hash
    witness     peer_id
    reason      string
    timestamp   timestamp
)

message ATTESTATION_SHARE from Witness to [Witness] (
    attestation  dict
)

# --- Witness -> Consumer/Provider ---
message ATTESTATION_RESULT from Witness to [Consumer, Provider] (
    attestation  dict
)

# =============================================================================
# FUNCTIONS (Transaction-specific helpers)
# =============================================================================

function count_positive_votes(votes list<dict>) -> uint (
    RETURN LENGTH(FILTER(votes, v => v.can_reach_vm == true))
)

function build_cabal_votes_map(votes list<dict>) -> map<peer_id, bool> (
    result = {}
    FOR v IN votes
        result[v.witness] = v.can_reach_vm
    RETURN result
)

native function check_vm_connectivity(vm_endpoint string) -> bool "omerta.native.vm_connectivity"

native function check_consumer_connected(session_id hash) -> bool "omerta.native.vm_connectivity"

# =============================================================================
# ACTORS
# =============================================================================

actor Provider "Allocates VM, notifies cabal, handles termination" (
    store (
        session_id           hash
        consumer             peer_id
        witnesses            list<peer_id>
        lock_result          dict
        lock_completed_at    timestamp
        vm_info              dict
        vm_allocated_at      timestamp
        vm_allocated_msg     dict
        notified_at          timestamp
        verification_passed  bool
        connectivity_votes   list<dict>
        termination_reason   TerminationReason
        cancelled_at         timestamp
        vm_cancelled_msg     dict
        cancellation_sent_at timestamp
        attestation          dict
    )

    trigger start_session(session_id hash, consumer peer_id, witnesses list<peer_id>, lock_result dict) in [WAITING_FOR_LOCK] "Called after escrow lock succeeds"
    trigger allocate_vm(vm_info dict) in [VM_PROVISIONING] "VM allocation completes"
    trigger cancel_session(reason TerminationReason) in [VM_RUNNING] "Initiate session cancellation"

    state WAITING_FOR_LOCK initial "Waiting for escrow lock to complete"
    state VM_PROVISIONING "Allocating VM resources"
    state NOTIFYING_CABAL "Sending VM_ALLOCATED to cabal"
    state WAITING_FOR_VERIFICATION "Waiting for cabal to verify connectivity"
    state VM_RUNNING "Session active, VM accessible"
    state HANDLING_CANCEL "Processing cancellation request"
    state SENDING_CANCELLATION "Notifying cabal of termination"
    state WAITING_FOR_ATTESTATION "Waiting for cabal attestation"
    state SESSION_COMPLETE "Attestation received, ready for settlement"
    state SESSION_ABORTED terminal "Session was aborted before completion"

    # Entry from escrow lock
    WAITING_FOR_LOCK -> VM_PROVISIONING on start_session (
        store session_id, consumer, witnesses, lock_result
        STORE(lock_completed_at, NOW())
    )

    # VM allocation timeout
    VM_PROVISIONING -> SESSION_ABORTED on timeout(VM_ALLOCATION_TIMEOUT) (
        STORE(termination_reason, TerminationReason.ALLOCATION_FAILED)
    )

    # VM allocation success
    VM_PROVISIONING -> NOTIFYING_CABAL on allocate_vm (
        store vm_info
        STORE(vm_allocated_at, NOW())
    )

    # Notify cabal and consumer
    NOTIFYING_CABAL -> WAITING_FOR_VERIFICATION auto (
        vm_allocated_msg = {session_id LOAD(session_id), provider peer_id, consumer LOAD(consumer), vm_info LOAD(vm_info), allocated_at LOAD(vm_allocated_at), lock_result_hash HASH(LOAD(lock_result)), timestamp NOW()}
        BROADCAST(witnesses, VM_ALLOCATED)
        SEND(consumer, VM_READY)
        STORE(notified_at, NOW())
        STORE(connectivity_votes, [])
    )

    # Collect connectivity votes
    WAITING_FOR_VERIFICATION -> WAITING_FOR_VERIFICATION on VM_CONNECTIVITY_VOTE (
        APPEND(connectivity_votes, message.payload)
    )

    # All votes received - check threshold
    WAITING_FOR_VERIFICATION -> VM_RUNNING auto when LENGTH(connectivity_votes) >= LENGTH(witnesses) and count_positive_votes(connectivity_votes) / LENGTH(connectivity_votes) >= CONNECTIVITY_THRESHOLD (
        STORE(verification_passed, true)
    )

    # Connectivity verification failed
    WAITING_FOR_VERIFICATION -> SENDING_CANCELLATION auto when LENGTH(connectivity_votes) >= LENGTH(witnesses) and count_positive_votes(connectivity_votes) / LENGTH(connectivity_votes) < CONNECTIVITY_THRESHOLD (
        STORE(verification_passed, false)
        STORE(termination_reason, TerminationReason.CONNECTIVITY_FAILED)
    )

    # Timeout - check if enough positive votes
    WAITING_FOR_VERIFICATION -> VM_RUNNING on timeout(CONNECTIVITY_CHECK_TIMEOUT) when LENGTH(connectivity_votes) > 0 and count_positive_votes(connectivity_votes) / LENGTH(connectivity_votes) >= CONNECTIVITY_THRESHOLD (
        STORE(verification_passed, true)
    )

    WAITING_FOR_VERIFICATION -> SENDING_CANCELLATION on timeout(CONNECTIVITY_CHECK_TIMEOUT) when LENGTH(connectivity_votes) == 0 or count_positive_votes(connectivity_votes) / LENGTH(connectivity_votes) < CONNECTIVITY_THRESHOLD (
        STORE(verification_passed, false)
        STORE(termination_reason, TerminationReason.CONNECTIVITY_FAILED)
    )

    # Consumer cancel request
    VM_RUNNING -> HANDLING_CANCEL on CANCEL_REQUEST when message.sender == LOAD(consumer) (
        STORE(termination_reason, TerminationReason.CONSUMER_REQUEST)
        STORE(cancelled_at, NOW())
    )

    # Provider-initiated cancel
    VM_RUNNING -> HANDLING_CANCEL on cancel_session (
        store reason
        STORE(termination_reason, reason)
        STORE(cancelled_at, NOW())
    )

    # Process cancellation
    HANDLING_CANCEL -> SENDING_CANCELLATION auto

    # Send cancellation to cabal
    SENDING_CANCELLATION -> WAITING_FOR_ATTESTATION auto (
        vm_cancelled_msg = {session_id LOAD(session_id), provider peer_id, cancelled_at LOAD(cancelled_at), reason LOAD(termination_reason), actual_duration_seconds LOAD(cancelled_at) - LOAD(vm_allocated_at), timestamp NOW()}
        BROADCAST(witnesses, VM_CANCELLED)
        SEND(consumer, SESSION_TERMINATED)
        STORE(cancellation_sent_at, NOW())
    )

    # Receive attestation
    WAITING_FOR_ATTESTATION -> SESSION_COMPLETE on ATTESTATION_RESULT (
        STORE(attestation, message.attestation)
    )
)

actor Witness "Verifies VM accessibility, monitors session, creates attestation" (
    store (
        session_id                hash
        consumer                  peer_id
        provider                  peer_id
        other_witnesses           list<peer_id>
        vm_allocated_msg          dict
        vm_allocated_at           timestamp
        witness                   peer_id
        can_reach_vm              bool
        can_see_consumer_connected bool
        vote_data                 dict
        vote_signature            signature
        my_connectivity_vote      dict
        connectivity_votes        list<dict>
        votes_sent_at             timestamp
        connectivity_verified     bool
        abort_reason              string
        abort_votes               list<dict>
        abort_votes_sent_at       timestamp
        session_aborted           bool
        vm_cancelled_msg          dict
        actual_duration_seconds   uint
        termination_reason        TerminationReason
        misuse_accusation         dict
        attestation               dict
        attestation_signatures    list<dict>
        attestation_sent_at       timestamp
    )

    trigger setup_session(session_id hash, consumer peer_id, provider peer_id, other_witnesses list<peer_id>) in [AWAITING_ALLOCATION] "Initialize witness with session info after escrow lock"

    state AWAITING_ALLOCATION initial "Waiting for VM_ALLOCATED from provider"
    state VERIFYING_VM "Checking VM connectivity"
    state COLLECTING_VOTES "Collecting connectivity votes from other witnesses"
    state EVALUATING_CONNECTIVITY "Deciding if VM is accessible"
    state MONITORING "Session running, periodic health checks"
    state HANDLING_MISUSE "Investigating misuse accusation"
    state VOTING_ABORT "Voting to abort session"
    state COLLECTING_ABORT_VOTES "Collecting abort votes from other witnesses"
    state ATTESTING "Creating attestation after session ends"
    state COLLECTING_ATTESTATION_SIGS "Multi-signing attestation"
    state PROPAGATING_ATTESTATION "Sending attestation to parties"
    state DONE terminal "Attestation complete"

    # Setup (called externally after escrow lock)
    AWAITING_ALLOCATION -> AWAITING_ALLOCATION on setup_session (
        store session_id, consumer, provider, other_witnesses
    )

    # Receive VM allocation from provider
    AWAITING_ALLOCATION -> VERIFYING_VM on VM_ALLOCATED (
        STORE(vm_allocated_msg, message.payload)
        STORE(vm_allocated_at, message.payload.allocated_at)
    )

    # Perform connectivity check and send vote
    VERIFYING_VM -> COLLECTING_VOTES auto (
        can_reach_vm = check_vm_connectivity(vm_allocated_msg.consumer_wireguard_endpoint)
        can_see_consumer_connected = check_consumer_connected(session_id)
        STORE(witness, peer_id)
        vote_data = {session_id LOAD(session_id), witness peer_id, can_reach_vm LOAD(can_reach_vm), can_see_consumer_connected LOAD(can_see_consumer_connected), timestamp NOW()}
        vote_signature = SIGN(LOAD(vote_data))
        my_connectivity_vote = {...LOAD(vote_data), signature LOAD(vote_signature)}
        BROADCAST(other_witnesses, VM_CONNECTIVITY_VOTE)
        SEND(provider, VM_CONNECTIVITY_VOTE)
        STORE(connectivity_votes, [LOAD(my_connectivity_vote)])
        STORE(votes_sent_at, NOW())
    )

    # Collect votes from other witnesses
    COLLECTING_VOTES -> COLLECTING_VOTES on VM_CONNECTIVITY_VOTE when message.payload.witness != peer_id (
        APPEND(connectivity_votes, message.payload)
    )

    # All votes received
    COLLECTING_VOTES -> EVALUATING_CONNECTIVITY auto when LENGTH(connectivity_votes) >= LENGTH(other_witnesses) + 1

    # Timeout waiting for votes
    COLLECTING_VOTES -> EVALUATING_CONNECTIVITY on timeout(CONNECTIVITY_VOTE_TIMEOUT)

    # Evaluate connectivity - success
    EVALUATING_CONNECTIVITY -> MONITORING auto when LENGTH(connectivity_votes) > 0 and count_positive_votes(connectivity_votes) / LENGTH(connectivity_votes) >= CONNECTIVITY_THRESHOLD (
        STORE(connectivity_verified, true)
    )

    # Evaluate connectivity - failure
    EVALUATING_CONNECTIVITY -> VOTING_ABORT auto when LENGTH(connectivity_votes) == 0 or count_positive_votes(connectivity_votes) / LENGTH(connectivity_votes) < CONNECTIVITY_THRESHOLD (
        STORE(connectivity_verified, false)
        STORE(abort_reason, "vm_unreachable")
    )

    # Session ends normally - provider sends cancellation
    MONITORING -> ATTESTING on VM_CANCELLED (
        STORE(vm_cancelled_msg, message.payload)
        STORE(actual_duration_seconds, message.payload.actual_duration_seconds)
        STORE(termination_reason, message.payload.reason)
    )

    # Misuse accusation received
    MONITORING -> HANDLING_MISUSE on MISUSE_ACCUSATION (
        STORE(misuse_accusation, message.payload)
    )

    # Investigate misuse - evidence found
    HANDLING_MISUSE -> VOTING_ABORT auto when LOAD(misuse_accusation).evidence != "" (
        STORE(abort_reason, "consumer_misuse")
    )

    # Investigate misuse - no evidence
    HANDLING_MISUSE -> MONITORING auto when LOAD(misuse_accusation).evidence == ""

    # Send abort vote
    VOTING_ABORT -> COLLECTING_ABORT_VOTES auto (
        abort_vote_data = {session_id LOAD(session_id), witness peer_id, reason LOAD(abort_reason), timestamp NOW()}
        abort_vote_signature = SIGN(LOAD(abort_vote_data))
        my_abort_vote = {...LOAD(abort_vote_data), signature LOAD(abort_vote_signature)}
        BROADCAST(other_witnesses, ABORT_VOTE)
        STORE(abort_votes, [LOAD(my_abort_vote)])
        STORE(abort_votes_sent_at, NOW())
    )

    # Collect abort votes
    COLLECTING_ABORT_VOTES -> COLLECTING_ABORT_VOTES on ABORT_VOTE when message.payload.witness != peer_id (
        APPEND(abort_votes, message.payload)
    )

    # Evaluate abort votes - threshold met
    COLLECTING_ABORT_VOTES -> ATTESTING auto when LENGTH(abort_votes) / (LENGTH(other_witnesses) + 1) >= ABORT_THRESHOLD (
        STORE(session_aborted, true)
        STORE(termination_reason, LOAD(abort_reason))
    )

    # Evaluate abort votes - threshold not met, return to monitoring
    COLLECTING_ABORT_VOTES -> MONITORING on timeout(ABORT_VOTE_TIMEOUT) when LENGTH(abort_votes) / (LENGTH(other_witnesses) + 1) < ABORT_THRESHOLD

    # Evaluate abort votes - timeout with threshold met
    COLLECTING_ABORT_VOTES -> ATTESTING on timeout(ABORT_VOTE_TIMEOUT) when LENGTH(abort_votes) / (LENGTH(other_witnesses) + 1) >= ABORT_THRESHOLD (
        STORE(session_aborted, true)
        STORE(termination_reason, LOAD(abort_reason))
    )

    # Create attestation
    ATTESTING -> COLLECTING_ATTESTATION_SIGS auto (
        attestation = {session_id LOAD(session_id), vm_allocated_hash HASH(LOAD(vm_allocated_msg)), vm_cancelled_hash HASH(LOAD(vm_cancelled_msg)), connectivity_verified LOAD(connectivity_verified), actual_duration_seconds LOAD(actual_duration_seconds), termination_reason LOAD(termination_reason), cabal_votes LOAD(connectivity_votes), cabal_signatures [], created_at NOW()}
        my_signature = SIGN(LOAD(attestation))
        STORE(attestation_signatures, [{witness peer_id, signature LOAD(my_signature)}])
        BROADCAST(other_witnesses, ATTESTATION_SHARE)
        STORE(attestation_sent_at, NOW())
    )

    # Collect attestation signatures
    COLLECTING_ATTESTATION_SIGS -> COLLECTING_ATTESTATION_SIGS on ATTESTATION_SHARE (
        APPEND(attestation_signatures, message.payload.attestation.cabal_signatures)
    )

    # Threshold signatures collected
    COLLECTING_ATTESTATION_SIGS -> PROPAGATING_ATTESTATION auto when LENGTH(attestation_signatures) >= ATTESTATION_THRESHOLD

    # Send attestation to parties
    PROPAGATING_ATTESTATION -> DONE auto (
        final_attestation = {...LOAD(attestation), cabal_signatures LOAD(attestation_signatures)}
        SEND(consumer, ATTESTATION_RESULT)
        SEND(provider, ATTESTATION_RESULT)
        APPEND(chain, ATTESTATION)
    )
)

actor Consumer "Connects to VM, uses service" (
    store (
        session_id          hash
        provider            peer_id
        vm_info             dict
        connected_at        timestamp
        termination_reason  TerminationReason
        attestation         dict
    )

    trigger setup_session(session_id hash, provider peer_id) in [WAITING_FOR_VM] "Initialize consumer with session info"
    trigger request_cancel() in [CONNECTED] "Request to end session early"

    state WAITING_FOR_VM initial "Waiting for VM to be ready"
    state CONNECTING "Connecting to VM via wireguard"
    state CONNECTED "Using the VM"
    state REQUESTING_CANCEL "Requesting session end"
    state SESSION_ENDED terminal "Session terminated"

    # Setup (called externally)
    WAITING_FOR_VM -> WAITING_FOR_VM on setup_session (
        store session_id, provider
    )

    # VM ready
    WAITING_FOR_VM -> CONNECTING on VM_READY (
        STORE(vm_info, message.vm_info)
    )

    # Connect to VM
    CONNECTING -> CONNECTED auto (
        STORE(connected_at, NOW())
    )

    # Session terminated by provider
    CONNECTED -> SESSION_ENDED on SESSION_TERMINATED (
        STORE(termination_reason, message.reason)
    )

    # Receive attestation while connected
    CONNECTED -> CONNECTED on ATTESTATION_RESULT (
        STORE(attestation, message.attestation)
    )

    # Request cancel
    CONNECTED -> REQUESTING_CANCEL on request_cancel

    # Send cancel request
    REQUESTING_CANCEL -> CONNECTED auto (
        SEND(provider, CANCEL_REQUEST)
    )

    # Receive attestation after session ended
    SESSION_ENDED -> SESSION_ENDED on ATTESTATION_RESULT (
        STORE(attestation, message.attestation)
    )
)
